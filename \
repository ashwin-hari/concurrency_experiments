#include <iostream>
#include <thread>
#include <future>
#include <vector>
#include <mutex>
#include <atomic>

using namespace std;


mutex print_mutex; 
mutex accum_mutex;

int square (int x) {
	return x * x;
}

void add_square (atomic<int>& accum, int x) {
	accum += x*x;
} 

void print_id (int id) {
	print_mutex.lock();
	cout << "thread id  " << id << endl;
	print_mutex.unlock();
}

void run_with_threads () {
	cout << "running with threads ... " << endl;
	atomic<int> accum(0);
	vector<std::thread> threads;
	int num_threads = 20; 
	for (int i = 0; i < num_threads; i++)
		threads.push_back(thread(add_square, ref(accum), i));
	
	for (auto& x : threads)
		x.join();

	cout << endl << "accum: " << accum << endl;

	// run print_id
	for (int i = 0; i < num_threads; i++)
		threads[i] = thread(print_id, i);
	for (auto& x : threads)
		x.join();
}

void run_with_future () {
	cout << "running with future objects ... " << endl;
	int accum = 0;
	vector<future<int>> futures;
	int num_futures = 20;
	for (int i = 0; i < num_futures; i++) {
		auto a = async(launch::async. add_square, ref(accum), i);
		futures.push_back(a);
	}

	for (auto& x  : futures)
		a.get();

	cout << "accum: " << accum << endl;
}

int main () {
	// run the accumulator	
	run_with_threads();
	run_with_future();
	return 0;
}
